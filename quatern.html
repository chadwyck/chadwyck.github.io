<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Quaternion Fractals - 3D/4D Fractals</title><link rel="stylesheet" href="./stylesheets/style.css"><link rel="stylesheet" href="./stylesheets/buttons.css"><meta name="viewport" content="initial-scale=1"><script src="./javascripts/jquery_2.1.0.js"></script><script src="./javascripts/jquery_ui_1.10.4.min.js"></script><script src="./javascripts/front.js"></script></head><body><div class="navbar"><a id="brand" href="./index.html"><img src="./images/FractalFlame2.jpg" class="brandImg"><p>Home</p></a><a href="./quatern.html" class="navLinks">Quaternion Fractals</a><a href="./flames.html" class="navLinks">3D Fractal Flames</a><a href="./use.html" class="navLinks">Use the Project</a><form method="get" action="./resources/Team_Aaron_Gabe_Chad_A_Plus_Best_Group.7z"><button type="submit" class="flat-button flat-button-2">project zip</button></form><form method="get" action="./resources/3D4DFractals.docx"><button type="submit" class="flat-button flat-button-2">paper</button></form><form method="get" action="./resources/graphics_final.pptx"><button type="submit" class="flat-button flat-button-2">slides</button></form></div><div class="container"><div class="mainTitle"><img src="./images/allTogether_trans.png" class="titleImg"><h2>Quaternion Fractals</h2><img src="./images/example_trans.png" class="titleImg"></div><h1 class="resultsTitle">Background and Fractal Generation</h1><div class="resultsPanel"><p>A quaternion is complex vector. This means that it has a real part, a, and then three imaginary parts, i, j, and k. So, we have this Quaternion, z. We then use the model:</p><div class="picContain"><img src="./images/equat_1.png" class="pictureCenter"></div><p>Which if we apply to itself repeatedly we are able to generate a fractal that is based on what we set c to. This process looks something like this:</p><div class="picContain"><img src="./images/equat_2.png" class="pictureCenter"></div><p>If we use the above limit, for c = 0, will have one of three results:</p><div class="picContain"><img src="./images/equat_3_2.png" style="width:40px;" class="pictureCenter">, <img src="./images/equat_3_1.png" class="pictureCenter"></div><p>If the magnitude of z is equal to 1 we know that the input is on the surface of the fractal. In this case the surface is simply a sphere.</p><p>For c != 0 we have the equation:</p><div class="picContain"><p><img src="./images/equat_4_1.png" style="width:40px;" class="pictureCenter">, <img src="./images/equat_4_2.png" class="pictureCenter"></p></div><p>The third result is the non-converging area, the strange attractor, and is what we are modeling.</p></div><h1 class="resultsTitle">Ray marching explaination</h1><div class="resultsPanel"><p>So, the next step is to somehow isolate the fractal in space and from there represent it. A naïve approach would be to shoot rays into the scene from the camera and then to slowly march outwards from the camera along each ray checking for the fractal as we go. This is obviously sub optimal as it is either slow, with small steps along the rays, or it is fast, but with such big steps that much of the fractal is lost. In order to solve this particular dilemma we needed a new way to find the fractal in space. We found an equation that allowed us to estimate the distance to the surface of the fractal given a certain point.    div.picContain</p><div class="picContain"><img src="./images/equat_5.png" class="pictureCenter"></div><p>This equation gives us the minimum distance in any direction that the fractal surface could be, and since we only care about the direction along the ray we are currently on we can use that distance as the size of our next step. Our final step to optimize the ray marching was to modulate the stopping epsilon as the ray gets further from the camera.</p><div class="picContain"><img src="./images/DistanceEstimator.png" class="pictureCenter"></div><p>At this point we have a bunch of data regarding the position of the fractal relative to the camera, and we can draw the fractal based on the distance from the camera, but we would like to do more. For example shadows, material application, and other cool effects we need the all-powerful normals that most surfaces have. </p><div class="picContain"><img src="./images/heightMap.jpg" class="pictureCenter"></div></div><h1 class="resultsTitle">Generating normals</h1><div class="resultsPanel"><p>Once we had built up the depth map using ray marching. We had to apply an algorithm to generate normals. To do this we took the gradient across each pixel using its two neighbors to calculate the derivatives. Because of the high level of detail on the fractal surface, our normals would sometimes look very noisy. To deal with this we super sampled the normals.</p><div class="picContain"><img src="./images/normals.jpg" class="pictureCenter"></div></div><h1 class="resultsTitle">Lights, Shadows, and Reflections</h1><div class="resultsPanel"><p>Lights and Shadows are implemented much like they were in our original ray tracers. Because we use the normal map to generate the normals on the fractal surface, we don’t support lights or reflections of the fractal in reflections due to the fact we would have to recalculate the height map from every angle that we wanted the fractal to be reflected along.</p><div class="picContain"><img src="./images/lights.jpg" class="pictureCenter"><img src="./images/shadows.jpg" class="pictureCenter"></div></div><h1 class="resultsTitle">Ambient Occlusion</h1><div class="resultsPanel"><p>Ambient Occlusion falls out of the ray marching process for free. Because we have a distance estimator formula, we can simply count the number of marches it takes to get to our final destination. If one pixel has more marches than another, it must have had to pass through a more complex portion of the scene.</p><div class="picContain"><img src="./images/ambientOcclusion.jpg" class="pictureCenter"><img src="./images/DistanceEstimator.png" class="pictureCenter"></div></div><h1 class="resultsTitle">Overall result</h1><div class="resultsPanel"><p>Here are some of the results of the process.</p><div class="picContain"><img src="./images/allTogether.jpg" class="pictureCenter"></div><div class="picContain"><img src="./images/example2.jpg" class="pictureCenter"></div><div class="picContain"><img src="./images/example1.jpg" class="pictureCenter"></div><div class="picContain"><img src="./images/reflect_100.jpg" class="pictureCenter"></div><div class="picContain"><img src="./images/reflect_50_2.jpg" class="pictureCenter"></div><div class="picContain"><img src="./images/cornell4.jpg" class="pictureCenter"></div><div class="picContain"><img src="./images/cornell1.png" class="pictureCenter"></div></div></div><footer><p>&copy 2014 - Aaron Golliver, Gabe Glenn, Chadwick Jones</p></footer></body></html>